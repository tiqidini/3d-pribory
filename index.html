<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Перевірка Габаритів 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        input[type=range] {
            -webkit-appearance: none; appearance: none; width: 100%; height: 8px;
            background: #d1d5db; outline: none; opacity: 0.7;
            -webkit-transition: .2s; transition: opacity .2s; border-radius: 4px;
        }
        input[type=range]:hover { opacity: 1; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 18px; height: 18px;
            background: #059669; cursor: pointer; border-radius: 50%;
        }
        input[type=range]::-moz-range-thumb {
            width: 18px; height: 18px; background: #059669; cursor: pointer;
            border-radius: 50%; border: none;
        }
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        #status-indicator { transition: background-color 0.3s ease; }
        .unit-label::after {
            content: " (" attr(data-unit) ")"; font-size: 0.75em; color: #6b7280;
        }
        .adjust-btn {
            width: 1.5rem; height: 1.5rem; line-height: 1.5rem;
            padding: 0; font-weight: bold; transition: background-color 0.15s ease;
        }
        select {
             background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
             background-position: right 0.5rem center;
             background-repeat: no-repeat;
             background-size: 1.5em 1.5em;
             padding-right: 2.5rem;
             -webkit-print-color-adjust: exact;
             print-color-adjust: exact;
             appearance: none; -webkit-appearance: none; -moz-appearance: none;
        }
        @media (max-width: 1023px) {
            .controls-panel { max-height: 55vh; }
            .canvas-container { min-height: 40vh; }
        }
        #suitableCasesList li { padding: 2px 0; border-bottom: 1px solid #eee; }
        #suitableCasesList li:last-child { border-bottom: none; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 flex flex-col lg:flex-row min-h-screen">

    <div class="w-full lg:w-1/4 p-6 bg-white shadow-lg overflow-y-auto controls-panel">
        <h1 class="text-2xl font-bold mb-6 text-gray-800">Перевірка Габаритів 3D</h1>

        <div class="mb-6">
            <label for="units" class="block text-sm font-medium text-gray-700 mb-1">Одиниці:</label>
            <select id="units" name="units" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                <option value="mm" selected>Міліметри (мм)</option>
                <option value="cm">Сантиметри (см)</option>
                <option value="in">Дюйми (in)</option>
            </select>
        </div>

        <div class="mb-4 flex items-center">
            <input id="twoDevicesCheckbox" name="twoDevicesCheckbox" type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
            <label for="twoDevicesCheckbox" class="ml-2 block text-sm font-medium text-gray-700">Використовувати два прилади</label>
        </div>

        <div id="deviceOneControls" class="mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
             <h2 class="text-lg font-semibold mb-3 text-gray-700">Прилад 1</h2>
             <div class="mb-4">
                 <label for="devicePreset1" class="block text-sm font-medium text-gray-700 mb-1">Пресет Приладу 1:</label>
                 <select id="devicePreset1" name="devicePreset1" class="device-preset-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                     <option value="">-- Вибрати пресет --</option>
                 </select>
             </div>
             <div class="grid grid-cols-1 gap-y-3">
                <div>
                    <label for="deviceL1" class="block text-xs font-medium text-gray-600 unit-label" data-unit="мм">Довжина (L)</label>
                    <div class="mt-1 flex items-center space-x-1">
                        <input type="number" id="deviceL1" value="50" min="0.1" step="any" class="dimension-input flex-grow border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 text-sm p-2">
                        <button class="adjust-btn bg-red-200 hover:bg-red-300 text-red-800 rounded" data-target="deviceL1" data-step="-1">-</button>
                        <button class="adjust-btn bg-green-200 hover:bg-green-300 text-green-800 rounded" data-target="deviceL1" data-step="1">+</button>
                    </div>
                </div>
                 <div>
                    <label for="deviceW1" class="block text-xs font-medium text-gray-600 unit-label" data-unit="мм">Ширина (W)</label>
                     <div class="mt-1 flex items-center space-x-1">
                        <input type="number" id="deviceW1" value="30" min="0.1" step="any" class="dimension-input flex-grow border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 text-sm p-2">
                        <button class="adjust-btn bg-red-200 hover:bg-red-300 text-red-800 rounded" data-target="deviceW1" data-step="-1">-</button>
                        <button class="adjust-btn bg-green-200 hover:bg-green-300 text-green-800 rounded" data-target="deviceW1" data-step="1">+</button>
                    </div>
                </div>
                 <div>
                    <label for="deviceH1" class="block text-xs font-medium text-gray-600 unit-label" data-unit="мм">Висота (H)</label>
                     <div class="mt-1 flex items-center space-x-1">
                        <input type="number" id="deviceH1" value="20" min="0.1" step="any" class="dimension-input flex-grow border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 text-sm p-2">
                        <button class="adjust-btn bg-red-200 hover:bg-red-300 text-red-800 rounded" data-target="deviceH1" data-step="-1">-</button>
                        <button class="adjust-btn bg-green-200 hover:bg-green-300 text-green-800 rounded" data-target="deviceH1" data-step="1">+</button>
                    </div>
                </div>
            </div>
        </div>

         <div id="deviceTwoControls" class="hidden mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
             <h2 class="text-lg font-semibold mb-3 text-gray-700">Прилад 2</h2>
             <div class="mb-4">
                 <label for="devicePreset2" class="block text-sm font-medium text-gray-700 mb-1">Пресет Приладу 2:</label>
                 <select id="devicePreset2" name="devicePreset2" class="device-preset-select mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                     <option value="">-- Вибрати пресет --</option>
                 </select>
             </div>
             <div class="grid grid-cols-1 gap-y-3">
                <div>
                    <label for="deviceL2" class="block text-xs font-medium text-gray-600 unit-label" data-unit="мм">Довжина (L)</label>
                    <div class="mt-1 flex items-center space-x-1">
                        <input type="number" id="deviceL2" value="50" min="0.1" step="any" class="dimension-input flex-grow border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 text-sm p-2">
                        <button class="adjust-btn bg-red-200 hover:bg-red-300 text-red-800 rounded" data-target="deviceL2" data-step="-1">-</button>
                        <button class="adjust-btn bg-green-200 hover:bg-green-300 text-green-800 rounded" data-target="deviceL2" data-step="1">+</button>
                    </div>
                </div>
                 <div>
                    <label for="deviceW2" class="block text-xs font-medium text-gray-600 unit-label" data-unit="мм">Ширина (W)</label>
                     <div class="mt-1 flex items-center space-x-1">
                        <input type="number" id="deviceW2" value="30" min="0.1" step="any" class="dimension-input flex-grow border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 text-sm p-2">
                        <button class="adjust-btn bg-red-200 hover:bg-red-300 text-red-800 rounded" data-target="deviceW2" data-step="-1">-</button>
                        <button class="adjust-btn bg-green-200 hover:bg-green-300 text-green-800 rounded" data-target="deviceW2" data-step="1">+</button>
                    </div>
                </div>
                 <div>
                    <label for="deviceH2" class="block text-xs font-medium text-gray-600 unit-label" data-unit="мм">Висота (H)</label>
                     <div class="mt-1 flex items-center space-x-1">
                        <input type="number" id="deviceH2" value="20" min="0.1" step="any" class="dimension-input flex-grow border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 text-sm p-2">
                        <button class="adjust-btn bg-red-200 hover:bg-red-300 text-red-800 rounded" data-target="deviceH2" data-step="-1">-</button>
                        <button class="adjust-btn bg-green-200 hover:bg-green-300 text-green-800 rounded" data-target="deviceH2" data-step="1">+</button>
                    </div>
                </div>
            </div>
        </div>

         <div id="deviceSpacingControls" class="hidden mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
            <label for="deviceSpacing" class="block text-xs font-medium text-gray-600 unit-label" data-unit="мм">Вертикальна відстань між приладами</label>
             <div class="mt-1 flex items-center space-x-1">
                <input type="number" id="deviceSpacing" value="10" min="0" step="1" class="dimension-input flex-grow border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 text-sm p-2">
                <button class="adjust-btn bg-red-200 hover:bg-red-300 text-red-800 rounded" data-target="deviceSpacing" data-step="-1">-</button>
                <button class="adjust-btn bg-green-200 hover:bg-green-300 text-green-800 rounded" data-target="deviceSpacing" data-step="1">+</button>
            </div>
         </div>


        <div class="mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
             <h2 class="text-lg font-semibold mb-3 text-gray-700">Ящик (Кейс)</h2>
             <div class="mb-4">
                 <label for="casePreset" class="block text-sm font-medium text-gray-700 mb-1">Пресет Кейсу (Внутр. розміри):</label>
                 <select id="casePreset" name="casePreset" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                     <option value="">-- Вибрати пресет --</option>
                 </select>
             </div>
             <div class="grid grid-cols-1 gap-y-3">
                 <div>
                    <label for="boxL" class="block text-xs font-medium text-gray-600 unit-label" data-unit="мм">Внутр. Довжина (L)</label>
                     <div class="mt-1 flex items-center space-x-1">
                        <input type="number" id="boxL" value="100" min="0.1" step="any" class="dimension-input flex-grow border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 text-sm p-2">
                        <button class="adjust-btn bg-red-200 hover:bg-red-300 text-red-800 rounded" data-target="boxL" data-step="-1">-</button>
                        <button class="adjust-btn bg-green-200 hover:bg-green-300 text-green-800 rounded" data-target="boxL" data-step="1">+</button>
                    </div>
                </div>
                 <div>
                    <label for="boxW" class="block text-xs font-medium text-gray-600 unit-label" data-unit="мм">Внутр. Ширина (W)</label>
                     <div class="mt-1 flex items-center space-x-1">
                        <input type="number" id="boxW" value="80" min="0.1" step="any" class="dimension-input flex-grow border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 text-sm p-2">
                        <button class="adjust-btn bg-red-200 hover:bg-red-300 text-red-800 rounded" data-target="boxW" data-step="-1">-</button>
                        <button class="adjust-btn bg-green-200 hover:bg-green-300 text-green-800 rounded" data-target="boxW" data-step="1">+</button>
                    </div>
                </div>
                 <div>
                    <label for="boxH" class="block text-xs font-medium text-gray-600 unit-label" data-unit="мм">Внутр. Висота (H)</label>
                     <div class="mt-1 flex items-center space-x-1">
                        <input type="number" id="boxH" value="50" min="0.1" step="any" class="dimension-input flex-grow border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 text-sm p-2">
                        <button class="adjust-btn bg-red-200 hover:bg-red-300 text-red-800 rounded" data-target="boxH" data-step="-1">-</button>
                        <button class="adjust-btn bg-green-200 hover:bg-green-300 text-green-800 rounded" data-target="boxH" data-step="1">+</button>
                    </div>
                </div>
             </div>
        </div>

        <div class="mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
             <h2 class="text-lg font-semibold mb-3 text-gray-700">Обертання приладів</h2> <div class="space-y-3">
                <div>
                    <label for="rotateX" class="block text-xs font-medium text-gray-600">Вісь X (<span id="rotateXValue">0</span>°)</label>
                    <input type="range" id="rotateX" min="0" max="360" value="0" step="1" class="mt-1 w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
                 <div>
                    <label for="rotateY" class="block text-xs font-medium text-gray-600">Вісь Y (<span id="rotateYValue">0</span>°)</label>
                    <input type="range" id="rotateY" min="0" max="360" value="0" step="1" class="mt-1 w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
                 <div>
                    <label for="rotateZ" class="block text-xs font-medium text-gray-600">Вісь Z (<span id="rotateZValue">0</span>°)</label>
                    <input type="range" id="rotateZ" min="0" max="360" value="0" step="1" class="mt-1 w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>
             <button id="resetRotation" class="mt-4 w-full bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-md text-sm transition duration-150 ease-in-out">
                Скинути обертання
            </button>
        </div>

        <div class="mt-auto pt-4 space-y-4">
            <div>
                 <h2 class="text-lg font-semibold mb-2 text-gray-700">Статус сумісності</h2>
                 <div id="status-indicator" class="p-3 rounded-lg text-center font-semibold text-white bg-gray-400">
                     <span id="status-text">Введіть розміри</span>
                 </div>
            </div>
             <div id="clearance-section" class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                <h3 class="text-md font-semibold mb-2 text-gray-700">Залишок місця (зазор):</h3>
                <div class="text-sm space-y-1 text-gray-600">
                    <p>Довжина (L): <span id="clearanceL" class="font-medium text-gray-800">-</span> <span class="unit-label" data-unit="мм"></span></p>
                    <p>Ширина (W): <span id="clearanceW" class="font-medium text-gray-800">-</span> <span class="unit-label" data-unit="мм"></span></p>
                    <p>Висота (H): <span id="clearanceH" class="font-medium text-gray-800">-</span> <span class="unit-label" data-unit="мм"></span></p>
                </div>
            </div>
            <div class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                <h3 class="text-md font-semibold mb-2 text-gray-700">Підходящі пресети кейсів:</h3>
                <ol id="suitableCasesList" class="text-sm list-decimal list-inside space-y-1 text-gray-600 max-h-40 overflow-y-auto">
                    <li class="text-gray-400 italic">Розрахунок...</li>
                </ol>
            </div>
        </div>

    </div>

    <div id="container3d" class="flex-1 bg-gray-200 relative canvas-container">
        <div id="loading-indicator" class="absolute inset-0 flex items-center justify-center bg-gray-200 bg-opacity-75 z-10">
            <p class="text-gray-700 text-lg">Завантаження 3D сцени...</p>
        </div>
    </div>

    <script>
        // --- Глобальні змінні Three.js ---
        let scene, camera, renderer, controls, gridHelper;
        let boxMesh;
        let deviceGroup1, deviceCollisionMesh1; // Для першого приладу
        let deviceGroup2, deviceCollisionMesh2; // Для другого приладу
        let boxBoundingBox;
        const deviceColorFit = 0x10B981;
        const deviceColorNoFit = 0xEF4444;
        const boxColor = 0x3B82F6;
        const boxWireframeColor = 0x1E40AF;
        const deviceBaseColor = 0x6B7280;
        const buttonColor = 0x4B5563;
        const screenColor = 0x9CA3AF;
        const epsilon = 0.01;

        // --- Елементи UI ---
        const container3d = document.getElementById('container3d');
        const loadingIndicator = document.getElementById('loading-indicator');
        const unitSelect = document.getElementById('units');
        const twoDevicesCheckbox = document.getElementById('twoDevicesCheckbox'); // Чекбокс
        // Прилад 1
        const deviceLInput1 = document.getElementById('deviceL1');
        const deviceWInput1 = document.getElementById('deviceW1');
        const deviceHInput1 = document.getElementById('deviceH1');
        const devicePresetSelect1 = document.getElementById('devicePreset1');
        // Прилад 2
        const deviceTwoControlsDiv = document.getElementById('deviceTwoControls'); // Контейнер для приладу 2
        const deviceLInput2 = document.getElementById('deviceL2');
        const deviceWInput2 = document.getElementById('deviceW2');
        const deviceHInput2 = document.getElementById('deviceH2');
        const devicePresetSelect2 = document.getElementById('devicePreset2');
        // Відстань
        const deviceSpacingControlsDiv = document.getElementById('deviceSpacingControls'); // Контейнер для відстані
        const deviceSpacingInput = document.getElementById('deviceSpacing');
        // Ящик
        const boxLInput = document.getElementById('boxL');
        const boxWInput = document.getElementById('boxW');
        const boxHInput = document.getElementById('boxH');
        const casePresetSelect = document.getElementById('casePreset');
        // Обертання
        const rotateXSlider = document.getElementById('rotateX');
        const rotateYSlider = document.getElementById('rotateY');
        const rotateZSlider = document.getElementById('rotateZ');
        const rotateXValueSpan = document.getElementById('rotateXValue');
        const rotateYValueSpan = document.getElementById('rotateYValue');
        const rotateZValueSpan = document.getElementById('rotateZValue');
        const resetRotationButton = document.getElementById('resetRotation');
        // Статус та інше
        const statusIndicator = document.getElementById('status-indicator');
        const statusText = document.getElementById('status-text');
        const unitLabels = document.querySelectorAll('.unit-label');
        const adjustButtons = document.querySelectorAll('.adjust-btn');
        const dimensionInputs = document.querySelectorAll('.dimension-input');
        const clearanceLSpan = document.getElementById('clearanceL');
        const clearanceWSpan = document.getElementById('clearanceW');
        const clearanceHSpan = document.getElementById('clearanceH');
        const suitableCasesListElement = document.getElementById('suitableCasesList');


        // --- Фактори конвертації в мм ---
        const conversionFactors = { mm: 1, cm: 10, in: 25.4 };

         // --- Пресети кейсів (Внутрішні розміри в мм) ---
        const casePresets = {};

        // --- Пресети приладів (Розміри в мм L x W x H) ---
        const devicePresets = {
            "Осцилограф Tektronix TDS3054C (375x176x149)": { l: 375, w: 176, h: 149 },
            "Генератор R&S HMF2550 (285x365x75)": { l: 285, w: 365, h: 75 }
        };


        // --- Функція для парсингу списку пресетів кейсів ---
        function parseAndSetCasePresets(presetString) {
            const lines = presetString.trim().split('\n');
            const regex = /^(.*?)\s+(\d+)\s*[xх]\s*(\d+)\s*[xх]\s*(\d+)$/;
            lines.forEach(line => {
                const match = line.trim().match(regex);
                if (match) {
                    let name = match[1].trim();
                    name = name.replace(/ Кейс$/i, '').trim();
                    name = name.replace(/^Кейс\s+/i, '').trim();
                    name = name.replace(/^Peli\s*(?:Storm|Air|Protector|Ruck|HardBack)?\s*/i, '').trim();
                     if (!name.toLowerCase().startsWith('peli') && !name.toLowerCase().startsWith('im')) { name = `Peli ${name}`; }
                    const l = parseInt(match[2], 10);
                    const w = parseInt(match[3], 10);
                    const h = parseInt(match[4], 10);
                    if (name && !isNaN(l) && !isNaN(w) && !isNaN(h) && l > 0 && w > 0 && h > 0) {
                        const key = `${name} (${l}x${w}x${h})`;
                        casePresets[key] = { l, w, h };
                    } else { console.warn("Skipping invalid case preset line:", line); }
                } else { console.warn("Could not parse case preset line:", line); }
            });
             console.log("Parsed case presets:", casePresets);
        }

        // --- Рядок з пресетами кейсів від користувача ---
        const userCasePresetString = `
Peli Protector Длинномерный кейс Peli 1700 908 x 343 x 133
Длинномерный кейс Peli 1720 1066 x 343 x 133
Длинномерный кейс Peli 1740 1040 x 328 x 308
Длинномерный кейс Peli 1750 1282 x 343 x 133
Длинномерный кейс Peli 1770 1386 x 396 x 219
Кейс Peli 0340 457 x 457 x 457
Кейс Peli 0350 508 x 508 x 508
Кейс Peli 0370 609 x 609 x 609
Кейс Peli 0500 888 x 469 x 641
Кейс Peli 0550 1208 x 611 x 449
Кейс Peli 0915 122 x 57 x 14
Кейс Peli 1010 111 x 73 x 43
Кейс Peli 1015 131 x 67 x 35
Кейс Peli 1020 135 x 90 x 43
Кейс Peli 1030 162 x 67 x 52
Кейс Peli 1040 165 x 98 x 44
Кейс Peli 1050 160 x 93 x 70
Кейс Peli 1060 210 x 108 x 57
Кейс Peli 1120 185 x 121 x 85
Кейс Peli 1150 211 x 147 x 95
Peli Storm Кейс Peli Storm iM2075 241 x 191 x 184
Кейс Peli Storm iM2100 330 x 234 x 152
Кейс Peli Storm iM2200 381 x 267 x 152
Кейс Peli Storm iM2275 359 x 335 x 251
Кейс Peli Storm iM2300 432 x 297 x 157
Кейс Peli Storm iM2306 432 x 160 x 157
Кейс Peli Storm iM2370 462 x 307 x 132
Кейс Peli Storm iM2400 457 x 330 x 170
Кейс Peli Storm iM2450 457 x 330 x 213
Кейс Peli Storm iM2500 520 x 292 x 183
Кейс Peli Storm iM2600 508 x 355 x 196
Кейс Peli Storm iM2620 508 x 355 x 254
Кейс Peli Storm iM2700 559 x 432 x 203
Кейс Storm iM2720 559 x 432 x 254
Кейс Storm iM2750 559 x 432 x 322
Кейс Storm iM2875 571 x 536 x 289
Кейс Storm iM2950 736 x 457 x 267
Кейс Storm iM2975 736 x 457 x 350
Кейс Storm iM3075 757 x 528 x 452
Оружейный кейс Storm iM3200 1118 x 356 x 152
Peli AirКейс Peli Air 1465 473 x 254 x 278
Кейс Peli Air 1465 EMS (медичний) 473 x 254 x 278
Кейс Peli Air 1485 451 x 259 x 156
Кейс Peli Air 1506 475 x 239 x 198
Кейс Peli Air 1507 385 x 289 x 216
Кейс Peli Air 1525 521 x 287 x 171
Кейс Peli Air 1535 518 x 284 x 183
Кейс Peli Air 1555 584 x 324 x 191
Кейс Peli Air 1556 549 x 273 x 228
Кейс Peli Air 1557 440 x 330 x 248
Кейс Peli Air 1605 660 x 356 x 213
Кейс Peli Air 160 7535 x 402 x 295
Кейс Peli Air 1615 752 x 394 x 238
Кейс Peli Air 1626 715 x 358 x 298
Кейс Peli Air 1637 595 x 446 x 337
Кейс Peli Air 1745 1118 x 426 x 202
Кейс Peli Air 1606 623 x 312 x 260
Кейс Peli Air 1755 1397 x 356 x 203
Кейс Peli Air 1646 814 x 403 x 341
Peli Ruck Персональний кейс Peli Ruck R60 283 x 174 x 99
Peli HardBackКейс 1075 HardBack 282 x 201 x 41
        `;

        // --- Ініціалізація ---
        function init() {
            console.log("3D Check: Init...");
            if (!container3d) { /* ... error handling ... */ return; }

            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                const aspect = container3d.clientWidth / container3d.clientHeight;
                if (aspect === 0 || !isFinite(aspect)) { console.warn("3D Check: Invalid aspect ratio during init."); }
                camera = new THREE.PerspectiveCamera(50, aspect || 1, 0.1, 15000);
                camera.position.set(150, 150, 250);
                camera.lookAt(0, 0, 0);

                const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
                hemiLight.position.set(0, 200, 0);
                scene.add(hemiLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
                dirLight.position.set(60, 120, 90);
                scene.add(dirLight);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container3d.clientWidth, container3d.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                container3d.appendChild(renderer.domElement);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.1;
                controls.screenSpacePanning = true;
                controls.minDistance = 10;
                controls.maxDistance = 10000;

                gridHelper = new THREE.GridHelper(2000, 40, 0xcccccc, 0xcccccc);
                gridHelper.material.opacity = 0.3;
                gridHelper.material.transparent = true;
                scene.add(gridHelper);

                parseAndSetCasePresets(userCasePresetString);
                populateCasePresetDropdown();
                populateDevicePresetDropdown();

                // Важливо: встановлюємо дефолтний пресет ПЕРЕД першим createObjects
                setDefaultDevicePreset(); // Встановлює розміри для приладу 1

                createObjects(); // Створює об'єкти на основі полів вводу
                addEventListeners();
                updateUnitLabels();
                animate();

                loadingIndicator.style.display = 'none';
                console.log("3D Check: Init successful.");

            } catch (error) { /* ... error handling ... */ }
        }

        // --- Функція для створення 2D форми з заокругленими кутами ---
        function createRoundedRectShape(x, y, width, height, radius) {
            const shape = new THREE.Shape();
            radius = Math.max(0, Math.min(radius, width / 2, height / 2));
            shape.moveTo(x, y + radius);
            shape.lineTo(x, y + height - radius);
            shape.quadraticCurveTo(x, y + height, x + radius, y + height);
            shape.lineTo(x + width - radius, y + height);
            shape.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
            shape.lineTo(x + width, y + radius);
            shape.quadraticCurveTo(x + width, y, x + width - radius, y);
            shape.lineTo(x + radius, y);
            shape.quadraticCurveTo(x, y, x, y + radius);
            return shape;
        }


        // --- Створення Ящика (Кейса) - Заокруглена модель ---
        function createBox(innerWidth, innerHeight, innerDepth) {
            const boxGroup = new THREE.Group();
            const mainMaterial = new THREE.MeshStandardMaterial({
                color: boxColor, roughness: 0.3, metalness: 0.1,
                transparent: true, opacity: 0.5, side: THREE.DoubleSide
            });
            const visualWallThickness = Math.min(innerWidth, innerHeight, innerDepth) * 0.03 + 1;
            const outerWidth = innerWidth + 2 * visualWallThickness;
            const outerHeight = innerHeight + 2 * visualWallThickness;
            const outerDepth = innerDepth + 2 * visualWallThickness;
            const cornerRadius = Math.min(outerWidth, outerDepth) * 0.05;
            const roundedRectShape = createRoundedRectShape(-outerWidth / 2, -outerDepth / 2, outerWidth, outerDepth, cornerRadius);
            const extrudeSettings = { steps: 1, depth: outerHeight, bevelEnabled: false };
            const boxGeometry = new THREE.ExtrudeGeometry(roundedRectShape, extrudeSettings);
            boxGeometry.center();
            boxGeometry.rotateX(-Math.PI / 2);
            const mainBox = new THREE.Mesh(boxGeometry, mainMaterial);
            boxGroup.add(mainBox);
             try {
                 const edges = new THREE.EdgesGeometry(boxGeometry, 1);
                 const lineMaterial = new THREE.LineBasicMaterial({ color: boxWireframeColor, linewidth: 1 });
                 const wireframe = new THREE.LineSegments(edges, lineMaterial);
                 mainBox.add(wireframe);
             } catch (e) { console.warn("Could not create edges for rounded box:", e); }
            return boxGroup;
        }

        // --- Створення Приладу ---
        function createDevice(width, height, depth) {
             const group = new THREE.Group();
             const bodyMat = new THREE.MeshStandardMaterial({ color: deviceBaseColor, roughness: 0.6, metalness: 0.1 });
             const screenMat = new THREE.MeshStandardMaterial({ color: screenColor, roughness: 0.8, metalness: 0.0 });
             const buttonMat = new THREE.MeshStandardMaterial({ color: buttonColor, roughness: 0.7, metalness: 0.1 });
             const bodyGeo = new THREE.BoxGeometry(width, height, depth);
             const body = new THREE.Mesh(bodyGeo, bodyMat);
             group.add(body);
             const frontPanelZ = depth / 2 + 0.1;
             const screenWidth = width * 0.4; const screenHeight = height * 0.5; const screenDepth = depth * 0.02;
             const screenGeo = new THREE.BoxGeometry(screenWidth, screenHeight, screenDepth);
             const screen = new THREE.Mesh(screenGeo, screenMat);
             screen.position.set(-width * 0.25, height * 0.1, frontPanelZ - screenDepth / 2);
             body.add(screen);
             const buttonSize = Math.min(width, height) * 0.06; const buttonDepth = depth * 0.04;
             const buttonGeo = new THREE.BoxGeometry(buttonSize, buttonSize, buttonDepth);
             for (let i = 0; i < 4; i++) {
                 const button = new THREE.Mesh(buttonGeo, buttonMat);
                 const yPos = height * 0.3 - i * (buttonSize + buttonSize * 0.5);
                 button.position.set(-width * 0.02, yPos, frontPanelZ); body.add(button);
             }
             const numpadCols = 3; const numpadRows = 4;
             const numpadStartX = width * 0.1; const numpadStartY = height * 0.3;
             const numpadSpacingX = buttonSize * 1.8; const numpadSpacingY = buttonSize * 1.8;
             for (let row = 0; row < numpadRows; row++) {
                 for (let col = 0; col < numpadCols; col++) {
                     if ((row === numpadRows - 1 && col === 0) || (row === numpadRows - 1 && col === 2)) continue;
                     const button = new THREE.Mesh(buttonGeo, buttonMat);
                     const xPos = numpadStartX + col * numpadSpacingX; const yPos = numpadStartY - row * numpadSpacingY;
                     button.position.set(xPos, yPos, frontPanelZ); body.add(button);
                 }
             }
             const usbWidth = width * 0.05; const usbHeight = height * 0.1; const usbDepth = depth * 0.03;
             const usbGeo = new THREE.BoxGeometry(usbWidth, usbHeight, usbDepth);
             const usb = new THREE.Mesh(usbGeo, buttonMat);
             usb.position.set(-width * 0.4, -height * 0.35, frontPanelZ); body.add(usb);
             const collisionGeo = new THREE.BoxGeometry(width, height, depth);
             const collisionMat = new THREE.MeshBasicMaterial({ visible: false });
             const collisionMesh = new THREE.Mesh(collisionGeo, collisionMat);
             return { visibleGroup: group, collisionMesh: collisionMesh };
        }


        // --- Створення та оновлення 3D об'єктів ---
        function createObjects() {
            console.log("3D Check: createObjects()...");
            // --- Очищення сцени ---
            if (boxMesh) { scene.remove(boxMesh); boxMesh.traverse(child => { if (child.geometry) child.geometry.dispose(); if (child.material) { if (Array.isArray(child.material)) child.material.forEach(mat => mat.dispose()); else child.material.dispose(); } }); boxMesh = null;}
            if (deviceGroup1) { scene.remove(deviceGroup1); deviceGroup1.traverse(child => { if (child.geometry) child.geometry.dispose(); if (child.material) { if (Array.isArray(child.material)) child.material.forEach(mat => mat.dispose()); else child.material.dispose(); } }); deviceGroup1 = null;}
            if (deviceCollisionMesh1) { scene.remove(deviceCollisionMesh1); if(deviceCollisionMesh1.geometry) deviceCollisionMesh1.geometry.dispose(); if(deviceCollisionMesh1.material) deviceCollisionMesh1.material.dispose(); deviceCollisionMesh1 = null;}
            if (deviceGroup2) { scene.remove(deviceGroup2); deviceGroup2.traverse(child => { if (child.geometry) child.geometry.dispose(); if (child.material) { if (Array.isArray(child.material)) child.material.forEach(mat => mat.dispose()); else child.material.dispose(); } }); deviceGroup2 = null;}
            if (deviceCollisionMesh2) { scene.remove(deviceCollisionMesh2); if(deviceCollisionMesh2.geometry) deviceCollisionMesh2.geometry.dispose(); if(deviceCollisionMesh2.material) deviceCollisionMesh2.material.dispose(); deviceCollisionMesh2 = null;}
            boxBoundingBox = null;

            // --- Отримання розмірів ---
            const units = unitSelect.value;
            const factor = conversionFactors[units];
            const useTwoDevices = twoDevicesCheckbox.checked;

            // Розміри ящика (внутрішні)
            const boxL = Math.max(0.1, parseFloat(boxLInput.value) * factor);
            const boxW = Math.max(0.1, parseFloat(boxWInput.value) * factor);
            const boxH = Math.max(0.1, parseFloat(boxHInput.value) * factor);

            // Розміри приладу 1
            const devL1 = Math.max(0.1, parseFloat(deviceLInput1.value) * factor);
            const devW1 = Math.max(0.1, parseFloat(deviceWInput1.value) * factor);
            const devH1 = Math.max(0.1, parseFloat(deviceHInput1.value) * factor);

            console.log(`3D Check: Box Inner (mm): ${boxL}x${boxW}x${boxH}`);
            console.log(`3D Check: Device 1 (mm): ${devL1}x${devW1}x${devH1}`);

            // --- Створення Ящика ---
            try {
                boxMesh = createBox(boxL, boxH, boxW); // width=L, height=H, depth=W
                scene.add(boxMesh);
                console.log("3D Check: Box created");
            } catch (error) { console.error("3D Check: Box creation error:", error); updateStatus("Помилка геометрії ящика", "bg-red-500"); return; }

             // --- Створення Приладу 1 ---
             try {
                 const deviceData1 = createDevice(devL1, devH1, devW1); // width=L, height=H, depth=W
                 deviceGroup1 = deviceData1.visibleGroup;
                 deviceCollisionMesh1 = deviceData1.collisionMesh;
                 scene.add(deviceGroup1);
                 scene.add(deviceCollisionMesh1);
                 console.log("3D Check: Device 1 created");
             } catch(error) { console.error("3D Check: Device 1 creation error:", error); updateStatus("Помилка геометрії приладу 1", "bg-red-500"); return; }

            // --- Створення Приладу 2 (якщо потрібно) ---
            let devL2 = 0, devW2 = 0, devH2 = 0, spacing = 0;
            if (useTwoDevices) {
                devL2 = Math.max(0.1, parseFloat(deviceLInput2.value) * factor);
                devW2 = Math.max(0.1, parseFloat(deviceWInput2.value) * factor);
                devH2 = Math.max(0.1, parseFloat(deviceHInput2.value) * factor);
                spacing = Math.max(0, parseFloat(deviceSpacingInput.value) * factor);
                console.log(`3D Check: Device 2 (mm): ${devL2}x${devW2}x${devH2}, Spacing: ${spacing}`);

                try {
                    const deviceData2 = createDevice(devL2, devH2, devW2); // width=L, height=H, depth=W
                    deviceGroup2 = deviceData2.visibleGroup;
                    deviceCollisionMesh2 = deviceData2.collisionMesh;
                    scene.add(deviceGroup2);
                    scene.add(deviceCollisionMesh2);
                    console.log("3D Check: Device 2 created");
                } catch(error) { console.error("3D Check: Device 2 creation error:", error); updateStatus("Помилка геометрії приладу 2", "bg-red-500"); return; }

                // --- Позиціонування двох приладів ---
                const totalDeviceHeight = devH1 + spacing + devH2;
                // Y координата центру першого приладу (знизу)
                const y1 = -(spacing / 2 + devH2 / 2);
                // Y координата центру другого приладу (зверху)
                const y2 = spacing / 2 + devH1 / 2;

                deviceGroup1.position.y = y1;
                deviceCollisionMesh1.position.y = y1;
                deviceGroup2.position.y = y2;
                deviceCollisionMesh2.position.y = y2;

            } else {
                // Якщо тільки один прилад, центруємо його по Y
                deviceGroup1.position.y = 0;
                deviceCollisionMesh1.position.y = 0;
            }


            // --- Створення Bounding Box для ВНУТРІШНЬОГО простору ящика ---
            boxBoundingBox = new THREE.Box3(
                new THREE.Vector3(-boxL / 2, -boxH / 2, -boxW / 2),
                new THREE.Vector3(boxL / 2, boxH / 2, boxW / 2)
            );
            console.log(`3D Check: Box Inner BBox created (LWH): ${boxL}x${boxW}x${boxH}`);

            applyDeviceRotation(); // Застосовуємо поточне обертання
            checkCollision(); // Перевіряємо зіткнення та оновлюємо список кейсів
            centerCamera(); // Центруємо камеру
        }

        // --- Застосування обертання до приладів ---
        function applyDeviceRotation() {
             if (!deviceGroup1 || !deviceCollisionMesh1) return; // Потрібен хоча б перший
            const rotX = THREE.MathUtils.degToRad(parseFloat(rotateXSlider.value));
            const rotY = THREE.MathUtils.degToRad(parseFloat(rotateYSlider.value));
            const rotZ = THREE.MathUtils.degToRad(parseFloat(rotateZSlider.value));

            // Обертаємо перший прилад
            deviceGroup1.rotation.set(rotX, rotY, rotZ, 'ZYX');
            deviceCollisionMesh1.rotation.set(rotX, rotY, rotZ, 'ZYX');

            // Обертаємо другий прилад, якщо він існує
            if (deviceGroup2 && deviceCollisionMesh2) {
                 deviceGroup2.rotation.set(rotX, rotY, rotZ, 'ZYX');
                 deviceCollisionMesh2.rotation.set(rotX, rotY, rotZ, 'ZYX');
            }

            rotateXValueSpan.textContent = rotateXSlider.value;
            rotateYValueSpan.textContent = rotateYSlider.value;
            rotateZValueSpan.textContent = rotateZSlider.value;
            checkCollision(); // Перевірка зіткнення та оновлення списку кейсів
        }

        // --- Перевірка зіткнення, розрахунок зазору та оновлення списку кейсів ---
        function checkCollision() {
            const useTwoDevices = twoDevicesCheckbox.checked;

            // Перевіряємо наявність необхідних об'єктів
            if (!deviceCollisionMesh1 || !boxBoundingBox || (useTwoDevices && !deviceCollisionMesh2)) {
                 updateStatus("Очікування...", "bg-gray-400");
                 updateClearanceDisplay(null, null, null);
                 updateSuitableCasesList([]);
                 return;
            }

            // Оновлюємо матриці світу
            deviceCollisionMesh1.updateMatrixWorld();
            if (useTwoDevices) {
                deviceCollisionMesh2.updateMatrixWorld();
            }

            // --- Перевірка вершин ---
            let allVertices = [];
            let fits = true;

            // Вершини першого приладу
            const geom1 = deviceCollisionMesh1.geometry;
            if (!geom1 || !geom1.getAttribute('position')) { updateStatus("Помилка геометрії 1", "bg-red-500"); updateClearanceDisplay(null, null, null); updateSuitableCasesList([]); return; }
            const posAttr1 = geom1.getAttribute('position');
            for (let i = 0; i < posAttr1.count; i++) { const v = new THREE.Vector3(); v.fromBufferAttribute(posAttr1, i); allVertices.push(v.applyMatrix4(deviceCollisionMesh1.matrixWorld)); }

            // Вершини другого приладу (якщо є)
            if (useTwoDevices) {
                const geom2 = deviceCollisionMesh2.geometry;
                if (!geom2 || !geom2.getAttribute('position')) { updateStatus("Помилка геометрії 2", "bg-red-500"); updateClearanceDisplay(null, null, null); updateSuitableCasesList([]); return; }
                const posAttr2 = geom2.getAttribute('position');
                for (let i = 0; i < posAttr2.count; i++) { const v = new THREE.Vector3(); v.fromBufferAttribute(posAttr2, i); allVertices.push(v.applyMatrix4(deviceCollisionMesh2.matrixWorld)); }
            }

            // Перевірка всіх вершин
            const checkBox = new THREE.Box3(boxBoundingBox.min.clone().addScalar(epsilon), boxBoundingBox.max.clone().subScalar(epsilon));
            for (const vertex of allVertices) {
                if (!checkBox.containsPoint(vertex)) { fits = false; break; }
            }

            // --- Розрахунок зазору (на основі комбінованого AABB) ---
            let clrL = null, clrW = null, clrH = null;
            let combinedDeviceSize = new THREE.Vector3(); // Розмір комбінованого AABB
            const combinedAABB = new THREE.Box3();

            if (fits) {
                 // Розраховуємо комбінований AABB
                 combinedAABB.setFromObject(deviceCollisionMesh1, true);
                 if (useTwoDevices) {
                     combinedAABB.expandByObject(deviceCollisionMesh2, true);
                 }
                 combinedDeviceSize = combinedAABB.getSize(new THREE.Vector3());
                 const innerBoxSize = boxBoundingBox.getSize(new THREE.Vector3());

                 clrL = innerBoxSize.x - combinedDeviceSize.x;
                 clrW = innerBoxSize.z - combinedDeviceSize.z; // W = Z
                 clrH = innerBoxSize.y - combinedDeviceSize.y; // H = Y
            }
             updateClearanceDisplay(clrL, clrW, clrH);


            // --- Оновлення статусу та кольорів ---
            updateStatus(fits ? "Вміщується" : "Не вміщується", fits ? "bg-green-500" : "bg-red-500");
            // Колір першого приладу
            if (deviceGroup1 && deviceGroup1.children.length > 0) {
                 const body1 = deviceGroup1.children[0];
                 if (body1 && body1.isMesh) { body1.material.color.setHex(fits ? deviceColorFit : deviceColorNoFit); }
            }
             // Колір другого приладу
             if (useTwoDevices && deviceGroup2 && deviceGroup2.children.length > 0) {
                 const body2 = deviceGroup2.children[0];
                 if (body2 && body2.isMesh) { body2.material.color.setHex(fits ? deviceColorFit : deviceColorNoFit); }
             }


            // --- Пошук та сортування підходящих кейсів ---
            const fittingCases = [];
             // Використовуємо розмір комбінованого AABB для пошуку кейсів
             // Якщо не 'fits', combinedDeviceSize може бути не розрахований, тому беремо AABB першого
             const checkDeviceSize = fits ? combinedDeviceSize : new THREE.Box3().setFromObject(deviceCollisionMesh1, true).getSize(new THREE.Vector3());
             // Якщо два прилади, але вони не вміщуються, треба розрахувати комбінований AABB все одно для пошуку
             if (useTwoDevices && !fits) {
                  const tempCombinedAABB = new THREE.Box3().setFromObject(deviceCollisionMesh1, true);
                  tempCombinedAABB.expandByObject(deviceCollisionMesh2, true);
                  checkDeviceSize.copy(tempCombinedAABB.getSize(new THREE.Vector3()));
             }


            for (const presetName in casePresets) {
                const preset = casePresets[presetName];
                if (preset.l >= checkDeviceSize.x - epsilon &&
                    preset.h >= checkDeviceSize.y - epsilon && // H = Y
                    preset.w >= checkDeviceSize.z - epsilon) { // W = Z

                    const clearanceSum = (preset.l - checkDeviceSize.x) +
                                         (preset.w - checkDeviceSize.z) +
                                         (preset.h - checkDeviceSize.y);
                    fittingCases.push({ name: presetName, clearanceSum: clearanceSum });
                }
            }
            fittingCases.sort((a, b) => a.clearanceSum - b.clearanceSum);
            updateSuitableCasesList(fittingCases);
        }

         // --- Оновлення відображення залишку місця ---
         function updateClearanceDisplay(clrL, clrW, clrH) {
             const factor = conversionFactors[unitSelect.value];
             const format = (val) => (val !== null && val >= -epsilon) ? (val / factor).toFixed(1) : "-";
             if (clearanceLSpan) clearanceLSpan.textContent = format(clrL);
             if (clearanceWSpan) clearanceWSpan.textContent = format(clrW);
             if (clearanceHSpan) clearanceHSpan.textContent = format(clrH);
             document.querySelectorAll('#clearance-section .unit-label').forEach(label => {
                 label.setAttribute('data-unit', unitSelect.value);
             });
         }

         // --- Оновлення списку підходящих кейсів в UI ---
         function updateSuitableCasesList(fittingCases) {
             if (!suitableCasesListElement) return;
             suitableCasesListElement.innerHTML = ''; // Очистити список

             if (fittingCases.length === 0) {
                 const li = document.createElement('li');
                 li.textContent = 'Підходящих пресетів не знайдено';
                 li.className = 'text-gray-400 italic';
                 suitableCasesListElement.appendChild(li);
             } else {
                 fittingCases.forEach(item => {
                     const li = document.createElement('li');
                     li.textContent = item.name;
                     suitableCasesListElement.appendChild(li);
                 });
             }
         }


         // --- Оновлення текстового статусу та фону ---
        function updateStatus(text, bgColorClass) {
            statusText.textContent = text;
            statusIndicator.className = `p-3 rounded-lg text-center font-semibold text-white ${bgColorClass}`;
        }

        // --- Центрування та масштабування камери ---
        function centerCamera() {
             if (!boxMesh || !camera || !controls) return;
            console.log("3D Check: Centering camera...");
            const boundingBox = new THREE.Box3().setFromObject(boxMesh); // Центруємо по візуальному ящику
            // Додатково розширимо bounding box, щоб включити прилади, якщо вони виходять за межі візуального ящика (малоймовірно, але про всяк випадок)
            if (deviceGroup1) boundingBox.expandByObject(deviceGroup1);
            if (deviceGroup2) boundingBox.expandByObject(deviceGroup2);

            const center = boundingBox.getCenter(new THREE.Vector3());
            const size = boundingBox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim === 0 || !isFinite(maxDim)) { return; }
            const fitHeightDistance = maxDim / (2 * Math.atan(Math.PI * camera.fov / 360));
            const fitWidthDistance = fitHeightDistance / camera.aspect;
            // Збільшено коефіцієнт для більшого віддалення
            const distance = 1.9 * Math.max(fitHeightDistance, fitWidthDistance); // Збільшено до 1.9
            const finalDistance = Math.max(controls.minDistance * 1.5, Math.min(distance, controls.maxDistance * 0.8));
             if (!isFinite(finalDistance)) { console.warn("Calculated camera distance is not finite."); return; }
            const direction = new THREE.Vector3(0.6, 0.5, 1).normalize();
            const newPosition = center.clone().add(direction.multiplyScalar(finalDistance));
            camera.position.copy(newPosition);
            camera.lookAt(center);
            controls.target.copy(center);
            controls.update();
            console.log("3D Check: Camera centered.");
        }

        // --- Цикл анімації ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (renderer && scene && camera) { renderer.render(scene, camera); }
        }

         // --- Оновлення міток одиниць вимірювання ---
        function updateUnitLabels() {
             const selectedOption = unitSelect.options[unitSelect.selectedIndex];
            const selectedUnit = selectedOption.value;
            unitLabels.forEach(label => { label.setAttribute('data-unit', selectedUnit); });
             updateClearanceDisplay(
                 parseFloat(clearanceLSpan?.textContent) * conversionFactors[selectedUnit] || null,
                 parseFloat(clearanceWSpan?.textContent) * conversionFactors[selectedUnit] || null,
                 parseFloat(clearanceHSpan?.textContent) * conversionFactors[selectedUnit] || null
             );
            console.log("3D Check: Unit labels updated to:", selectedUnit);
        }

        // --- Заповнення списку пресетів кейсів ---
        function populateCasePresetDropdown() {
            casePresetSelect.innerHTML = '<option value="">-- Вибрати пресет --</option>';
            const sortedKeys = Object.keys(casePresets).sort((a, b) => {
                 const numA = parseInt(a.replace(/[^0-9]/g, ''), 10) || 0;
                 const numB = parseInt(b.replace(/[^0-9]/g, ''), 10) || 0;
                 if (numA !== numB) return numA - numB;
                 return a.localeCompare(b);
            });
            sortedKeys.forEach(name => {
                 const option = document.createElement('option');
                 option.value = name;
                 option.textContent = name;
                 casePresetSelect.appendChild(option);
            });
             console.log("3D Check: Case Preset dropdown populated.");
        }

         // --- Заповнення списку пресетів приладів ---
        function populateDevicePresetDropdown() {
            // Заповнюємо обидва списки
            [devicePresetSelect1, devicePresetSelect2].forEach(select => {
                 if (!select) return; // Перевірка на випадок помилки в HTML
                 select.innerHTML = '<option value="">-- Вибрати пресет --</option>';
                 for (const name in devicePresets) {
                     const option = document.createElement('option');
                     option.value = name;
                     option.textContent = name;
                     select.appendChild(option);
                 }
            });
            console.log("3D Check: Device Preset dropdowns populated.");
        }

         // --- Встановлення дефолтного пресету приладу ---
         function setDefaultDevicePreset() {
             const defaultPresetName = Object.keys(devicePresets)[0];
             if (defaultPresetName && devicePresetSelect1) { // Встановлюємо тільки для першого
                 devicePresetSelect1.value = defaultPresetName;
                 devicePresetSelect1.dispatchEvent(new Event('change'));
                 console.log("3D Check: Default device preset applied:", defaultPresetName);
             }
         }


        // --- Обробники подій ---
        function addEventListeners() {
            unitSelect.addEventListener('change', () => {
                updateUnitLabels();
                debounceCreateObjects();
            });

            // Обробник для всіх полів вводу розмірів
            dimensionInputs.forEach(input => {
                input.addEventListener('input', (e) => {
                     if (e.target.type === 'number' && parseFloat(e.target.value) < 0) e.target.value = '0';
                     // Мінімальне значення для відстані - 0
                     if (e.target.id === 'deviceSpacing' && parseFloat(e.target.value) < 0) e.target.value = '0';
                     debounceCreateObjects(150);
                });
            });

             // Обробник для +/- кнопок
             adjustButtons.forEach(button => {
                button.addEventListener('click', (event) => {
                    const targetId = event.currentTarget.dataset.target;
                    const step = parseFloat(event.currentTarget.dataset.step);
                    const targetInput = document.getElementById(targetId);
                    if (targetInput) {
                        let currentValue = parseFloat(targetInput.value) || 0;
                        let newValue = currentValue + step;
                        let minValue = (targetId === 'deviceSpacing') ? 0 : 0.1; // Мін. відстань 0
                        newValue = Math.max(minValue, newValue);
                        targetInput.value = parseFloat(newValue.toFixed(2));
                        targetInput.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                });
            });

            // Обробник для пресетів кейсів
            casePresetSelect.addEventListener('change', (event) => {
                const selectedPresetName = event.target.value;
                if (selectedPresetName && casePresets[selectedPresetName]) {
                    const preset = casePresets[selectedPresetName];
                    const factor = conversionFactors[unitSelect.value];
                    boxLInput.value = (preset.l / factor).toFixed(1);
                    boxWInput.value = (preset.w / factor).toFixed(1);
                    boxHInput.value = (preset.h / factor).toFixed(1);
                    boxLInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            });

             // Обробники для пресетів приладів
             [devicePresetSelect1, devicePresetSelect2].forEach((select, index) => {
                 if (!select) return;
                 select.addEventListener('change', (event) => {
                    const selectedPresetName = event.target.value;
                    if (selectedPresetName && devicePresets[selectedPresetName]) {
                        const preset = devicePresets[selectedPresetName];
                        const factor = conversionFactors[unitSelect.value];
                        const lInput = document.getElementById(`deviceL${index + 1}`);
                        const wInput = document.getElementById(`deviceW${index + 1}`);
                        const hInput = document.getElementById(`deviceH${index + 1}`);
                        if (lInput && wInput && hInput) {
                            lInput.value = (preset.l / factor).toFixed(1);
                            wInput.value = (preset.w / factor).toFixed(1);
                            hInput.value = (preset.h / factor).toFixed(1);
                            lInput.dispatchEvent(new Event('input', { bubbles: true }));
                        }
                    }
                });
             });

             // Обробник для чекбокса "Два прилади"
             twoDevicesCheckbox.addEventListener('change', (event) => {
                 const show = event.target.checked;
                 deviceTwoControlsDiv.classList.toggle('hidden', !show);
                 deviceSpacingControlsDiv.classList.toggle('hidden', !show);
                 debounceCreateObjects(); // Перестворити сцену
             });


            [rotateXSlider, rotateYSlider, rotateZSlider].forEach(slider => {
                slider.addEventListener('input', applyDeviceRotation);
            });

            resetRotationButton.addEventListener('click', () => {
                rotateXSlider.value = 0; rotateYSlider.value = 0; rotateZSlider.value = 0;
                applyDeviceRotation();
            });

            window.addEventListener('resize', onWindowResize, false);
        }

        // --- Debounce функція ---
        let debounceTimeout;
        function debounceCreateObjects(delay = 150) {
             clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(() => {
                 console.log("3D Check: Debounce triggered, calling createObjects()");
                 createObjects();
            }, delay);
        }

        // --- Обробник зміни розміру вікна ---
        function onWindowResize() {
             if (!camera || !renderer || !container3d) return;
            console.log("3D Check: Window resize");
            const width = container3d.clientWidth;
            const height = container3d.clientHeight;
             if (width === 0 || height === 0) return;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // --- Запуск додатка ---
        window.onload = function() {
            console.log("3D Check: window.onload");
            init();
        };

    </script>
</body>
</html>
